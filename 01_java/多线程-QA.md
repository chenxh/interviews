### 在 Java 程序中怎么保证多线程的运行安全？
出现线程安全问题的原因一般都是三个原因：
1. 线程切换带来的原子性问题
解决办法：使用多线程之间同步synchronized或使用锁(lock)。

2. CPU缓存导致的可见性问题
解决办法：synchronized、volatile、LOCK，可以解决可见性问题

3. 编译优化带来的有序性问题
解决办法：Happens-Before 规则可以解决有序性问题



### 什么是上下文切换?

* 多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。

* ***概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换***。

* 上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。

* Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少

### 减少上下文切换的方法：
* 无锁并发编程。多线程竞争时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash取模分段，不同的线程处理不同段的数据。
* CAS算法。Java的Atomic包使用CAS算法来更新数据，而不需要加锁。
* 使用最少线程。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态
* 协程。在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换

### 守护线程和用户线程有什么区别呢？
用户 (User) 线程：用户线程和守护线程唯一的区别就是Daemon（Thread.getDaemon()）为false；
守护 (Daemon) 线程：为程序提供后端服务的线程成为守护线程，非守护线程运行结束时守护线程也一并结束；

### Linux 上查找哪个线程cpu利用率最高?
1. 找出cpu耗用厉害的进程pid， 终端执行top命令，然后按下shift+p (shift+m是找出消耗内存最高)查找出cpu利用最厉害的pid号
2. 根据上面第一步拿到的pid号，top -H -p pid 。查找出cpu利用率最厉害的线程号，比如top -H -p 1328
3. 将获取到的线程号转换成16进制，去百度转换一下就行
4. 使用jstack工具将进程信息打印输出，jstack pid号 > /tmp/t.dat，比如jstack 31365 > /tmp/t.dat
5. 编辑/tmp/t.dat文件，查找线程号对应的信息

### 什么是线程死锁?



