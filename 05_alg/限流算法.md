## 限流的算法
常见的限流算法有：计数器、漏桶和令牌桶算法。

## 计数器
计数器是最简单粗暴的算法。比如某个服务最多只能每秒钟处理100个请求。我们可以设置一个1秒钟的滑动窗口，窗口中有10个格子，每个格子100毫秒，每100毫秒移动一次，每次移动都需要记录当前服务请求的次数。内存中需要保存10次的次数。可以用数据结构LinkedList来实现。格子每次移动的时候判断一次，当前访问次数和LinkedList中最后一个相差是否超过100，如果超过就需要限流了。


## 漏桶算法
* 一个固定容量的漏桶，按照常量固定速率流出水滴；

* 如果桶是空的，则不需流出水滴；

* 可以以任意速率流入水滴到漏桶；

* 如果流入水滴超出了桶的容量，则流入的水滴溢出了（被丢弃），而漏桶容量是不变的。

漏桶算法比较好实现，在单机系统中可以使用队列来实现，在分布式环境中消息中间件或者Redis都是可选的方案。 
java 线程中队列设置成固定， 线程数固定， reject策略为拒绝。

## 令牌桶算法
是一个存放固定容量令牌（token）的桶，按照固定速率往桶里添加令牌。令牌桶算法基本可以用下面的几个概念来描述：

* 令牌将按照固定的速率被放入令牌桶中。比如每秒放10个。
* 桶中最多存放b个令牌，当桶满时，新添加的令牌被丢弃或拒绝。
* 当一个n个字节大小的数据包到达，将从桶中删除n个令牌，接着数据包被发送到网络上。 
* 如果桶中的令牌不足n个，则不会删除令牌，且该数据包将被限流（要么丢弃，要么缓冲区等待）。

令牌桶可以在运行时控制和调整数据处理的速率，处理某时的突发流量。放令牌的频率增加可以提升整体数据处理的速度，而通过每次获取令牌的个数增加或者放慢令牌的发放速度和降低整体数据处理速度。而漏桶不行，因为它的流出速率是固定的，程序处理速度也是固定的。

guava 的 RateLimiter 实现了 令牌桶算法。 

RateLimiter 包含： 平滑突发限流(SmoothBursty)和平滑预热限流(SmoothWarmingUp)实现。
平滑预热限流(SmoothWarmingUp)实现。 需设置预热时间， 在这个时间内，慢慢把速度提升到设置的速度。

## Nginx 限流
* 通过 limit_req 等模块限制并发连接数。